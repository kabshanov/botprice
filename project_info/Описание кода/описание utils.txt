Ниже — общее описание структуры вашего проекта и того, **как** взаимодействуют файлы `shared_data.py`, `utils.py` и модули для сложных товаров (например, `apple_watch_utils.py`):

---

## **1. `shared_data.py`**

**Назначение:**  
- Хранит **общие данные** (глобальные переменные, словари, списки), которые нужны и «простому» поиску, и «сложным» товарам.  
- Избегает циклических импортов (когда один модуль импортирует другой, а тот, в свою очередь, импортирует первый).

**Содержимое (пример):**  
- `USER_DATA`: словарь для хранения товаров, которые бот уже распознал у конкретных пользователей.  
- `PRODUCT_LIBRARY`: основная библиотека продуктов и их алиасов.  
- `COMPLEX_BRANDS`: список «сложных» брендов (например, `"Apple Watch"`, `"iPad"`, и т. д.).  
- `SPECIAL_RULES`: правила вроде «eSim» / «Dual sim».  
- `COUNTRY_EMOJI_MAP` или `TEXT_TO_FLAG`: сопоставление между названиями стран и флагами.  
- И т. п.

Все остальные модули — `utils.py`, `apple_watch_utils.py` и т. д. — **подтягивают** эти данные из `shared_data.py`, что позволяет **не** делать «кольцевых» импортов.

---

## **2. `utils.py`**

**Основная логика по работе с товарами**:  
1. **Импортирует** нужные структуры и переменные из `shared_data.py`.  
2. Содержит **общие** функции:
   - `normalize_product_name()`: нормализует названия (приводит к нижнему регистру, убирает лишние пробелы и т. д.).  
   - `build_alias_dict()`: создаёт словарь «алиас → (бренд, модель, вариант)» для простого поиска.  
   - `find_product_cached()`, `find_closest_product_name()`: реализуют fuzzy-поиск для *простых* товаров.  
   - `apply_special_rules()`: правила вроде «Делать ли Dual SIM, eSIM…»  
   - `add_or_update_product()`: сохраняет данные в `USER_DATA`.  
   - `message_handler()`: главный обработчик входящего сообщения, который:
     1. Разбивает текст на строки  
     2. Пытается распознать (цена, название, страна, комментарии)  
     3. Проверяет, не «сложный» ли это бренд (см. **`find_complex_brand_model`** и **`handle_complex_brand`**)  
     4. Если **не сложный**, то пользуется обычным (простым) поиском в `ALIAS_DICT`.

3. **Обработка «сложных» товаров** (как Apple Watch) в `utils.py` теперь сведена к тому, что:
   - В `find_complex_brand_model()` мы смотрим, есть ли бренд в списке `COMPLEX_BRANDS`.  
   - Если бренд действительно сложный, вызываем **`handle_complex_brand()`**, которая, в свою очередь, передаёт управление конкретному модулю (например, `apple_watch_utils.py`).  

**Таким образом**, `utils.py` — это «каркас» всего парсинга. При «сложных» товарах он делегирует более детальный разбор соответствующим модулям.

---

## **3. Модули для сложных товаров** (например, `apple_watch_utils.py`)

- **Содержат** специфические функции для «склейки» итогового названия из разных атрибутов (размер корпуса, тип ремешка и т.д.).  
- **Импортируют** данные (`PRODUCT_LIBRARY`, `USER_DATA`) из `shared_data.py`.  
- При необходимости вызывают **общие** функции (например, `add_or_update_product`), либо через «ленивый импорт» из `utils`, либо (в идеале) тоже получают эти функции **в параметрах**.

### Пример взаимодействия:
1. В `message_handler()` выявили, что пользователь вводит что-то вроде «Apple Watch Series 10 42mm Jet Black Sport Band S/M».  
2. `message_handler()` проверяет: это «Apple Watch» → значит, **сложный** товар?  
3. Если сложный — вызывает `handle_complex_brand()`.  
4. Внутри `handle_complex_brand()` определяется, что это Apple Watch → вызывается `handle_apple_watch_product(...)`.  
5. `handle_apple_watch_product()` парсит атрибуты из строки (размер, цвет, ремешок...), «склеивает» итоговое название, добавляет товар в `USER_DATA`.  

В итоге получается:  
- **Простой** товар (например, iPhone) — обрабатывается внутри `utils.py` напрямую.  
- **Сложный** товар (например, Apple Watch) — переходит в свой специальный модуль, который разбирает комбинацию атрибутов.

---

## **Краткий ответ, чего мы добиваемся**

1. **Разделяем** два сценария:  
   - **Простой поиск**: когда название совпадает (точно или «fuzzy») с алиасом из `ALIAS_DICT` (`iPhone 16 Pro 512 White` и т. п.).  
   - **Сложный поиск**: когда нужно собрать название из отдельных атрибутов (как с Apple Watch — `42mm`, `Jet Black`, `Sport Band` и т. д.).

2. **Не ломаем** логику простого поиска, а просто **добавляем** логику для «сложных» товаров в отдельный модуль, чтобы код был **читаемым** и **расширяемым**.  
   - Если завтра появится другой сложный товар (например, iPad c атрибутами «Диагональ экрана», «Тип чипа» и т.д.), мы сделаем ещё один модуль — `ipad_utils.py`, не влезая в код Apple Watch.

3. **Избавляемся от циклического импорта**:  
   - Все **общие** переменные (каталог товаров, USER_DATA, спец. правила) лежат в `shared_data.py`.  
   - `utils.py` и модули вроде `apple_watch_utils.py` берут всё нужное из `shared_data.py`, не импортируя друг друга напрямую.  

Итог: **Поддерживаем два вида распознавания** (простой и сложный), при этом код хорошо структурирован и не «сваливается» в один большой файл.